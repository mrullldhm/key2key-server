import { prisma } from "../config/prisma.client.js";

export const getAllCredential = async (req, res, next) => {
  try {
    const userId = req.user.id;

    const userVault = await prisma.permission.findMany({
      where: {
        userId: userId,
      },
      include: {
        credential: {
          include: {
            folder: true,
            // ADD THIS BLOCK START
            user: { 
              select: {
                email: true, // This gets the owner's email
              },
            },
            // ADD THIS BLOCK END
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    res.status(200).json({
      success: true,
      message: "Vault retrieved successfully",
      data: userVault,
    });
  } catch (err) {
    next(err);
  }
};

export const getCredential = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const { id } = req.params; // UUID of the credential

    // Find permission first to ensure user has access
    const permission = await prisma.permission.findFirst({
      where: {
        userId: userId,
        credentialId: id,
      },
      include: {
        credential: {
          include: {
            folder: true, // Include folder if it exists
          },
        },
      },
    });

    if (!permission) {
      return res.status(404).json({
        success: false,
        error: "Credential not found or access denied",
      });
    }

    res.status(200).json({
      success: true,
      message: "Credential retrieved successfully",
      data: permission,
    });
  } catch (err) {
    next(err);
  }
};

export const createCredential = async (req, res, next) => {
  try {
    // Data from request
    const {
      title,
      logInUrl,
      notes,
      encryptedUsername,
      encryptedPassword,
      iv, //FRONTEND
      tag, // FRONTEND
      folderId,
      encryptedDataKey, // This is the Data Key, encrypted by the FRONTEND using the user's Public Key
    } = req.body;

    // Use a transaction method to ensure both records are created safely
    const userId = req.user.id;

    const result = await prisma.$transaction(async (tx) => {
      const credential = await tx.credential.create({
        data: {
          title,
          logInUrl,
          notes,
          encryptedUsername,
          encryptedPassword,
          iv,
          tag,
          userId, // The owner
          folderId: folderId || null,
        },
      });

      const permission = await tx.permission.create({
        data: {
          userId,
          credentialId: credential.id,
          encryptedDataKey,
          iv, // Note: You might want a separate IV for the key vs data
        },
      });

      return { credential, permission };
    });

    res.status(201).json({
      success: true,
      message: "Credential created and secured",
      data: result,
    });
  } catch (err) {
    next(err);
  }
};

export const updateCredential = async (req, res, next) => {
  try {
    const { id } = req.params; // Credential ID
    const userId = req.user.id;
    const {
      title,
      logInUrl,
      notes,
      encryptedUsername,
      encryptedPassword,
      iv,
      tag,
      favorite,
      folderId,
    } = req.body;

    // 1. Find the credential and verify ownership
    const credential = await prisma.credential.findUnique({
      where: { id },
    });

    if (!credential) {
      const error = new Error("Credential not found");
      error.statusCode = 404;
      throw error;
    }

    // Only the creator can update the main Credential record
    if (credential.userId !== userId) {
      const error = new Error(
        "Unauthorized: Only the owner can update this credential"
      );
      error.statusCode = 403;
      throw error;
    }

    // 2. Update the record
    const updatedCredential = await prisma.credential.update({
      where: { id },
      data: {
        title,
        logInUrl,
        notes,
        encryptedUsername, // New encrypted blob from frontend
        encryptedPassword, // New encrypted blob from frontend
        iv, // New IV generated by frontend
        tag, // New Tag generated by frontend
        favorite,
        folderId: folderId || null,
      },
    });

    res.status(200).json({
      success: true,
      message: "Credential updated successfully",
      data: updatedCredential,
    });
  } catch (err) {
    next(err);
  }
};

export const deleteCredential = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const credential = await prisma.credential.findUnique({ where: { id } });

    if (!credential || credential.userId !== userId) {
      const error = new Error("Credential not found or unauthorized");
      error.statusCode = 404;
      throw error;
    }

    await prisma.permission.deleteMany({
      where: { credentialId: id },
    });

    await prisma.credential.delete({ where: { id } });

    res.status(200).json({
      success: true,
      message: "Credential and all shared permissions deleted successfully",
    });
  } catch (err) {
    next(err);
  }
};

export const getShareCredential = async (req, res, next) => {
  try {
    // Logic:
    // 1. Get target user's Public Key.
    // 2. Decrypt current user's encryptedDataKey using their Private Key.
    // 3. Re-encrypt that Data Key with target's Public Key.
    // 4. Create a new record in the Permission table.
  } catch (err) {
    next(err);
  }
};